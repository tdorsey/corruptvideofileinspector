name: ðŸ¤– Issue Triage Agent

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write
  contents: read

jobs:
  triage-issue:
    if: |
      github.event.issue.state == 'open' && 
      contains(github.event.issue.labels.*.name, 'triage:agent-pending')
    runs-on: ubuntu-latest
    steps:
      - name: Preserve Original Issue Body
        uses: actions/github-script@v7
        id: preserve
        with:
          script: |
            const issue = context.payload.issue;
            const originalBody = issue.body || '';
            const issueTitle = issue.title || '';
            
            // Post comment with original content for data preservation
            const preservationComment = [
              '## ðŸ“‹ Original Issue Content (Preserved)',
              '',
              '> This comment preserves the original issue content before agent processing.',
              '> If any context was lost during formatting, refer to this archive.',
              '',
              '---',
              '',
              originalBody,
              '',
              '---',
              '',
              '*Archived by Issue Triage Agent*'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: preservationComment
            });
            
            // Store original body and title for next steps using environment files
            // This is more secure than using step outputs for user-provided content
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ORIGINAL_BODY<<EOF\n' + originalBody + '\nEOF\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ISSUE_TITLE<<EOF\n' + issueTitle + '\nEOF\n');

      - name: Classify Issue
        uses: actions/github-script@v7
        id: classify
        env:
          ORIGINAL_BODY: ${{ env.ORIGINAL_BODY }}
          ISSUE_TITLE: ${{ env.ISSUE_TITLE }}
        with:
          script: |
            // Read from environment variables (safer than interpolation)
            const originalBody = process.env.ORIGINAL_BODY || '';
            const issueTitle = process.env.ISSUE_TITLE || '';
            const content = (issueTitle + '\n' + originalBody).toLowerCase();
            
            // Classification keywords
            const bugKeywords = ['bug', 'error', 'crash', 'fail', 'broken', 'issue', 'problem', 'not working', 'exception', 'traceback'];
            const featureKeywords = ['feature', 'enhancement', 'request', 'add', 'improve', 'want', 'would be nice', 'suggestion', 'propose'];
            const docKeywords = ['documentation', 'docs', 'readme', 'typo', 'clarify', 'explain'];
            const perfKeywords = ['performance', 'slow', 'fast', 'optimize', 'speed', 'memory'];
            
            // Count keyword matches
            const countMatches = (keywords) => keywords.filter(k => content.includes(k)).length;
            
            const bugScore = countMatches(bugKeywords);
            const featureScore = countMatches(featureKeywords);
            const docScore = countMatches(docKeywords);
            const perfScore = countMatches(perfKeywords);
            
            const maxScore = Math.max(bugScore, featureScore, docScore, perfScore);
            
            let issueType = 'task';
            let confidence = 0;
            let gaps = [];
            
            // Determine issue type based on scores
            if (maxScore === 0) {
              issueType = 'task';
              confidence = 50;
              gaps.push('No clear category keywords detected');
            } else if (bugScore === maxScore && bugScore > 0) {
              issueType = 'bug';
              confidence = Math.min(95, 60 + (bugScore * 5));
              // Check for missing bug report elements
              if (!content.includes('step') && !content.includes('reproduce')) {
                gaps.push('Steps to reproduce missing');
              }
              if (!content.includes('version') && !content.includes('environment') && !content.includes('os')) {
                gaps.push('Environment information missing');
              }
              if (!content.includes('expect') && !content.includes('should')) {
                gaps.push('Expected behavior not specified');
              }
            } else if (featureScore === maxScore && featureScore > 0) {
              issueType = 'feature';
              confidence = Math.min(95, 60 + (featureScore * 5));
              // Check for missing feature request elements
              if (!content.includes('use case') && !content.includes('why') && !content.includes('benefit')) {
                gaps.push('Use case or benefit not specified');
              }
              if (!content.includes('example') && !content.includes('scenario')) {
                gaps.push('Example or scenario missing');
              }
            } else if (docScore === maxScore && docScore > 0) {
              issueType = 'documentation';
              confidence = Math.min(95, 60 + (docScore * 5));
            } else if (perfScore === maxScore && perfScore > 0) {
              issueType = 'performance';
              confidence = Math.min(95, 60 + (perfScore * 5));
              if (!content.includes('benchmark') && !content.includes('metric') && !content.includes('time')) {
                gaps.push('Performance metrics missing');
              }
            } else {
              issueType = 'task';
              confidence = 50;
            }
            
            // If content is very short, lower confidence
            if (originalBody.length < 50) {
              confidence = Math.max(30, confidence - 20);
              gaps.push('Issue description is brief');
            }
            
            // Store classification results in environment file (safer approach)
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ISSUE_TYPE=' + issueType + '\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'CONFIDENCE=' + confidence + '\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'GAPS<<EOF\n' + JSON.stringify(gaps) + '\nEOF\n');

      - name: Format Issue Body
        uses: actions/github-script@v7
        id: format
        env:
          ORIGINAL_BODY: ${{ env.ORIGINAL_BODY }}
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
        with:
          script: |
            const issue = context.payload.issue;
            const originalBody = process.env.ORIGINAL_BODY || '';
            const issueType = process.env.ISSUE_TYPE || 'task';
            
            // Helper function to build template body with proper newlines
            const buildBody = (sections) => sections.join('\n\n');
            
            let formattedBody = '';
            
            // Generate formatted body based on issue type
            switch (issueType) {
              case 'bug':
                formattedBody = buildBody([
                  '### Stakeholder Type',
                  'End User',
                  '### Component/Domain',
                  'Other',
                  '### I want to',
                  'Report and resolve the following issue:\n\n' + originalBody,
                  '### But',
                  'The application is not behaving as expected (see details above).',
                  '### This helps by',
                  'Fixing this issue to improve application reliability and user experience.',
                  '### Unlike',
                  'The expected behavior which should work correctly.',
                  '### Steps to Reproduce',
                  '_Please add detailed steps to reproduce this issue._',
                  '### Environment Information',
                  '_Please provide your environment details (OS, Python version, etc.)_',
                  '### Error Logs/Output',
                  '```\n(No logs provided in original submission)\n```'
                ]);
                break;
                
              case 'feature':
                formattedBody = buildBody([
                  '### Stakeholder Type',
                  'End User',
                  '### Component/Domain',
                  'Other',
                  '### I want to',
                  originalBody,
                  '### But',
                  'This functionality is not currently available.',
                  '### This helps by',
                  'Adding new capabilities that improve the user experience.',
                  '### Unlike',
                  'The current implementation which does not include this feature.',
                  '### Additional Context',
                  '_Please add any additional context about this feature request._'
                ]);
                break;
                
              case 'documentation':
                formattedBody = buildBody([
                  '### Stakeholder Type',
                  'End User',
                  '### Component/Domain',
                  'Documentation',
                  '### I want to',
                  'Improve the documentation:\n\n' + originalBody,
                  '### But',
                  'The current documentation needs updates or clarification.',
                  '### This helps by',
                  'Making the documentation clearer and more helpful for users.',
                  '### Unlike',
                  'The current documentation which may be incomplete or unclear.',
                  '### Documentation Details',
                  '_Please specify which documentation files or sections need updates._'
                ]);
                break;
                
              case 'performance':
                formattedBody = buildBody([
                  '### Stakeholder Type',
                  'End User',
                  '### Component/Domain',
                  'Other',
                  '### I want to',
                  'Address the following performance concern:\n\n' + originalBody,
                  '### But',
                  'The current performance is not optimal.',
                  '### This helps by',
                  'Improving application speed and efficiency.',
                  '### Unlike',
                  'The current implementation which may be slower than expected.',
                  '### Performance Details',
                  '_Please provide performance metrics, benchmarks, or specific scenarios._'
                ]);
                break;
                
              default: // task/chore
                formattedBody = buildBody([
                  '### Stakeholder Type',
                  'End User',
                  '### Component/Domain',
                  'Other',
                  '### I want to',
                  originalBody,
                  '### But',
                  'This task has not been addressed yet.',
                  '### This helps by',
                  'Completing this task to improve the project.',
                  '### Unlike',
                  'The current state which does not include this improvement.',
                  '### Maintenance Task Type',
                  'Other',
                  '### Specific Tasks',
                  '_Please specify the exact tasks to be completed._'
                ]);
            }
            
            // Update issue body
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: formattedBody
            });

      - name: Post Metadata Comment
        uses: actions/github-script@v7
        env:
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
          CONFIDENCE: ${{ env.CONFIDENCE }}
          GAPS: ${{ env.GAPS }}
        with:
          script: |
            const issue = context.payload.issue;
            const issueType = process.env.ISSUE_TYPE || 'task';
            const confidence = process.env.CONFIDENCE || '50';
            
            // Parse gaps safely
            let gaps = [];
            try {
              gaps = JSON.parse(process.env.GAPS || '[]');
            } catch (e) {
              console.log('Failed to parse gaps, using empty array');
              gaps = [];
            }
            
            // Build metadata comment
            let gapsList = gaps.length > 0 
              ? gaps.map(g => `- ${g}`).join('\n')
              : '- None identified';
            
            const metadataComment = [
              '## ðŸ¤– Agent Processing Metadata',
              '',
              '| Metric | Value |',
              '|--------|-------|',
              '| **Classification** | ' + issueType.charAt(0).toUpperCase() + issueType.slice(1) + ' |',
              '| **Confidence** | ' + confidence + '% |',
              '| **Processing Time** | ' + new Date().toISOString() + ' |',
              '',
              '### Gap Analysis',
              '',
              'The following information was not found in the original submission:',
              '',
              gapsList,
              '',
              '---',
              '',
              '> **Note**: This issue was automatically formatted by the Issue Triage Agent.',
              '> The original content has been preserved in a separate comment above.',
              '> Please review and update any missing sections as needed.'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: metadataComment
            });

      - name: Update Labels
        uses: actions/github-script@v7
        env:
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
        with:
          script: |
            const issue = context.payload.issue;
            const issueType = process.env.ISSUE_TYPE || 'task';
            
            // Remove triage:agent-pending label
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: 'triage:agent-pending'
              });
            } catch (e) {
              console.log('Label triage:agent-pending not found or already removed');
            }
            
            // Add triage:agent-processed label
            const labelsToAdd = ['triage:agent-processed'];
            
            // Add type-specific labels based on classification
            switch (issueType) {
              case 'bug':
                labelsToAdd.push('bug');
                break;
              case 'feature':
                labelsToAdd.push('feature');
                break;
              case 'documentation':
                labelsToAdd.push('documentation');
                break;
              case 'performance':
                labelsToAdd.push('performance');
                break;
              default:
                labelsToAdd.push('chore');
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labelsToAdd
            });
