name: ðŸ¤– Issue Triage Agent

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write
  contents: read

jobs:
  triage-issue:
    if: |
      github.event.issue.state == 'open' &&
      contains(github.event.issue.labels.*.name, 'triage:agent-pending') &&
      (
        github.event.action == 'opened' ||
        (github.event.action == 'labeled' && github.event.label.name == 'triage:agent-pending')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Preserve Original Issue Body
        uses: actions/github-script@v7
        id: preserve
        with:
          script: |
            const issue = context.payload.issue;
            const originalBody = issue.body || '';
            const issueTitle = issue.title || '';
            
            // Post comment with original content for data preservation
            const preservationComment = [
              '## ðŸ“‹ Original Issue Content (Preserved)',
              '',
              '> This comment preserves the original issue content before agent processing.',
              '> If any context was lost during formatting, refer to this archive.',
              '',
              '---',
              '',
              originalBody,
              '',
              '---',
              '',
              '*Archived by Issue Triage Agent*'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: preservationComment
            });
            
            // Store original body and title for next steps using environment files
            // This is more secure than using step outputs for user-provided content
            const MAX_ENV_VALUE_LENGTH = 30000;
            
            function sanitizeForEnv(name, value) {
              if (!value) {
                return '';
              }
              
              if (value.length <= MAX_ENV_VALUE_LENGTH) {
                return value;
              }
              
              const note = '\n\n[' + name + ' truncated to ' + MAX_ENV_VALUE_LENGTH + ' characters to fit GitHub Actions environment limits.]';
              const maxContentLength = MAX_ENV_VALUE_LENGTH - note.length;
              const truncatedValue = value.slice(0, Math.max(0, maxContentLength)) + note;
              
              console.warn('Value for ' + name + ' exceeded ' + MAX_ENV_VALUE_LENGTH + ' characters and was truncated before writing to GITHUB_ENV.');
              
              return truncatedValue;
            }
            
            const safeOriginalBody = sanitizeForEnv('ORIGINAL_BODY', originalBody);
            const safeIssueTitle = sanitizeForEnv('ISSUE_TITLE', issueTitle);
            
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ORIGINAL_BODY<<EOF\n' + safeOriginalBody + '\nEOF\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ISSUE_TITLE<<EOF\n' + safeIssueTitle + '\nEOF\n');

      - name: Classify Issue
        uses: actions/github-script@v7
        id: classify
        env:
          ORIGINAL_BODY: ${{ env.ORIGINAL_BODY }}
          ISSUE_TITLE: ${{ env.ISSUE_TITLE }}
        with:
          script: |
            // Read from environment variables (safer than interpolation)
            const originalBody = process.env.ORIGINAL_BODY || '';
            const issueTitle = process.env.ISSUE_TITLE || '';
            const content = (issueTitle + '\n' + originalBody).toLowerCase();
            
            // Classification keywords
            const bugKeywords = ['bug', 'error', 'crash', 'fail', 'broken', 'issue', 'problem', 'not working', 'exception', 'traceback'];
            const featureKeywords = ['feature', 'enhancement', 'request', 'add', 'improve', 'want', 'would be nice', 'suggestion', 'propose'];
            const docKeywords = ['documentation', 'docs', 'readme', 'typo', 'clarify', 'explain'];
            const perfKeywords = ['performance', 'slow', 'fast', 'optimize', 'speed', 'memory'];
            
            // Component detection keywords.
            // Specificity is achieved via the chosen keyword sets and the
            // scoring logic (counting matches), not by the order of entries.
            // Entries are listed from more specific to more general for readability.
            const componentKeywords = {
              'GitHub Actions': ['agent', 'agent file', '.github/agents', '.github/workflows', 'github actions', 'action', 'workflow file', 'yml workflow', 'yaml workflow', 'issue template'],
              'CI/CD': ['ci', 'cd', 'pipeline', 'continuous integration', 'continuous deployment', 'build pipeline', 'automation workflow'],
              'Trakt Integration': ['trakt', 'sync', 'watchlist', 'collection'],
              'Docker': ['docker', 'container', 'dockerfile', 'compose'],
              'CLI': ['cli', 'command line', 'command-line', 'terminal', 'console', 'argv'],
              'Scanner': ['scanner', 'scanning', 'scan', 'detect', 'detection', 'analyze', 'analysis'],
              'Config': ['config file', 'configuration file', 'config settings', 'config options', 'config.yaml', 'config.yml', 'app config', 'user config', 'yaml config'],
              'Reporter': ['reporter', 'report', 'summary', 'results'],
              'Output': ['output', 'export', 'csv', 'json', 'format'],
              'Tests': ['test', 'testing', 'pytest', 'unittest', 'coverage', 'mock'],
              'Documentation': ['documentation', 'docs', 'readme', 'guide', 'tutorial']
            };
            
            // Stakeholder detection keywords
            const stakeholderKeywords = {
              'Project Maintainer': ['maintain', 'maintainer', 'admin', 'release', 'deploy', 'merge', 'ci/cd', 'workflow'],
              'Contributor': ['contribute', 'contributor', 'pr', 'pull request', 'implement', 'refactor', 'code review'],
              'End User': ['user', 'install', 'run', 'use', 'help', 'how to', 'error message']
            };
            
            // Count keyword matches
            const countMatches = (keywords) => keywords.filter(k => content.includes(k)).length;
            
            // Detect component based on keywords
            let detectedComponent = 'Unknown';
            let maxComponentScore = 0;
            for (const [component, keywords] of Object.entries(componentKeywords)) {
              const score = countMatches(keywords);
              if (score > maxComponentScore) {
                maxComponentScore = score;
                detectedComponent = component;
              }
            }
            
            // If no matches found, detectedComponent remains 'Unknown'
            
            // Detect stakeholder based on keywords
            let detectedStakeholder = 'End User';
            let maxStakeholderScore = 0;
            for (const [stakeholder, keywords] of Object.entries(stakeholderKeywords)) {
              const score = countMatches(keywords);
              if (score > maxStakeholderScore) {
                maxStakeholderScore = score;
                detectedStakeholder = stakeholder;
              }
            }
            
            const bugScore = countMatches(bugKeywords);
            const featureScore = countMatches(featureKeywords);
            const docScore = countMatches(docKeywords);
            const perfScore = countMatches(perfKeywords);
            
            const maxScore = Math.max(bugScore, featureScore, docScore, perfScore);
            
            // Calculate keyword density for tie-breaking
            const bugDensity = bugScore / bugKeywords.length;
            const featureDensity = featureScore / featureKeywords.length;
            const docDensity = docScore / docKeywords.length;
            const perfDensity = perfScore / perfKeywords.length;
            
            let issueType = 'task';
            let confidence = 0;
            let gaps = [];
            
            // Determine issue type based on scores with density tie-breaking
            if (maxScore === 0) {
              issueType = 'task';
              confidence = 50;
              gaps.push('No clear category keywords detected');
            } else {
              // Find all types with the max score
              const candidates = [];
              if (bugScore === maxScore) candidates.push({ type: 'bug', density: bugDensity });
              if (featureScore === maxScore) candidates.push({ type: 'feature', density: featureDensity });
              if (docScore === maxScore) candidates.push({ type: 'documentation', density: docDensity });
              if (perfScore === maxScore) candidates.push({ type: 'performance', density: perfDensity });
              
              // Use density as tie-breaker
              candidates.sort((a, b) => b.density - a.density);
              issueType = candidates[0].type;
              
              // Calculate base confidence from keyword matches (more conservative)
              const baseConfidence = Math.min(90, 40 + (maxScore * 4));
              let completenessPenalty = 0;
              
              if (issueType === 'bug') {
                // Check for missing bug report elements
                if (!content.includes('step') && !content.includes('reproduce')) {
                  gaps.push('Steps to reproduce missing');
                  completenessPenalty += 10;
                }
                if (!content.includes('version') && !content.includes('environment') && !content.includes('os')) {
                  gaps.push('Environment information missing');
                  completenessPenalty += 10;
                }
                if (!content.includes('expect') && !content.includes('should')) {
                  gaps.push('Expected behavior not specified');
                  completenessPenalty += 10;
                }
                // Check for missing code snippets or error logs
                if (!content.includes('```') && !content.includes('error') && !content.includes('exception') && 
                    !content.includes('traceback') && !content.includes('stack trace') && !content.includes('log')) {
                  gaps.push('Code snippet or error log/stack trace missing');
                  completenessPenalty += 5;
                }
              } else if (issueType === 'feature') {
                // Check for missing feature request elements
                if (!content.includes('use case') && !content.includes('why') && !content.includes('benefit')) {
                  gaps.push('Use case or benefit not specified');
                  completenessPenalty += 10;
                }
                if (!content.includes('example') && !content.includes('scenario')) {
                  gaps.push('Example or scenario missing');
                  completenessPenalty += 10;
                }
              } else if (issueType === 'performance') {
                if (!content.includes('benchmark') && !content.includes('metric') && !content.includes('time')) {
                  gaps.push('Performance metrics missing');
                  completenessPenalty += 10;
                }
              }
              
              // Reduce confidence when important details are missing
              confidence = Math.max(30, baseConfidence - completenessPenalty);
            }
            
            // If content is very short, lower confidence
            if (originalBody.length < 50) {
              confidence = Math.max(30, confidence - 20);
              gaps.push('Issue description is brief');
            }
            
            // Override issue type for agent/workflow-related work
            // Agent and workflow file work should NEVER be classified as feature
            if ((detectedComponent === 'GitHub Actions' || detectedComponent === 'CI/CD') && issueType === 'feature') {
              issueType = 'task';
              console.log('Overriding issue type from "feature" to "task" for GitHub Actions/CI/CD component');
            }
            
            // Store classification results in environment file (safer approach)
            const fs = require('fs');
            fs.appendFileSync(process.env.GITHUB_ENV, 'ISSUE_TYPE=' + issueType + '\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'CONFIDENCE=' + confidence + '\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'GAPS<<EOF\n' + JSON.stringify(gaps) + '\nEOF\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'DETECTED_COMPONENT=' + detectedComponent + '\n');
            fs.appendFileSync(process.env.GITHUB_ENV, 'DETECTED_STAKEHOLDER=' + detectedStakeholder + '\n');

      - name: Format Issue Body
        uses: actions/github-script@v7
        id: format
        env:
          ORIGINAL_BODY: ${{ env.ORIGINAL_BODY }}
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
          DETECTED_COMPONENT: ${{ env.DETECTED_COMPONENT }}
          DETECTED_STAKEHOLDER: ${{ env.DETECTED_STAKEHOLDER }}
        with:
          script: |
            const issue = context.payload.issue;
            const originalBody = process.env.ORIGINAL_BODY || '';
            const issueType = process.env.ISSUE_TYPE || 'task';
            const detectedComponent = process.env.DETECTED_COMPONENT || 'Unknown';
            const detectedStakeholder = process.env.DETECTED_STAKEHOLDER || 'End User';
            
            // Remove tags like [QUICK], [FEAT], [FIX], etc. from the title
            let cleanedTitle = issue.title || '';
            cleanedTitle = cleanedTitle.replace(/^\[?[A-Z]+\]?:\s*/i, '').trim();
            
            // Helper function to build template body with proper newlines
            const buildBody = (sections) => sections.join('\n\n');
            
            let formattedBody = '';
            
            // Generate formatted body based on issue type
            // Note: Component/Domain and Stakeholder Type are now applied as labels instead of being in the body
            switch (issueType) {
              case 'bug':
                formattedBody = buildBody([
                  '### I want to',
                  'Report and resolve the following issue:\n\n' + originalBody,
                  '### But',
                  'The application is not behaving as expected (see details above).',
                  '### This helps by',
                  'Fixing this issue to improve application reliability and user experience.',
                  '### Unlike',
                  'The expected behavior which should work correctly.',
                  '### Steps to Reproduce',
                  '_Please add detailed steps to reproduce this issue._',
                  '### Environment Information',
                  '_Please provide your environment details (OS, Python version, etc.)_',
                  '### Error Logs/Output',
                  '```\n(No logs provided in original submission)\n```'
                ]);
                break;
                
              case 'feature':
                formattedBody = buildBody([
                  '### I want to',
                  originalBody,
                  '### But',
                  'This functionality is not currently available.',
                  '### This helps by',
                  'Adding new capabilities that improve the user experience.',
                  '### Unlike',
                  'The current implementation which does not include this feature.',
                  '### Additional Context',
                  '_Please add any additional context about this feature request._'
                ]);
                break;
                
              case 'documentation':
                formattedBody = buildBody([
                  '### I want to',
                  'Improve the documentation:\n\n' + originalBody,
                  '### But',
                  'The current documentation needs updates or clarification.',
                  '### This helps by',
                  'Making the documentation clearer and more helpful for users.',
                  '### Unlike',
                  'The current documentation which may be incomplete or unclear.',
                  '### Documentation Details',
                  '_Please specify which documentation files or sections need updates._'
                ]);
                break;
                
              case 'performance':
                formattedBody = buildBody([
                  '### I want to',
                  'Address the following performance concern:\n\n' + originalBody,
                  '### But',
                  'The current performance is not optimal.',
                  '### This helps by',
                  'Improving application speed and efficiency.',
                  '### Unlike',
                  'The current implementation which may be slower than expected.',
                  '### Performance Details',
                  '_Please provide performance metrics, benchmarks, or specific scenarios._'
                ]);
                break;
                
              default: // task/chore
                formattedBody = buildBody([
                  '### I want to',
                  originalBody,
                  '### But',
                  'This task has not been addressed yet.',
                  '### This helps by',
                  'Completing this task to improve the project.',
                  '### Unlike',
                  'The current state which does not include this improvement.',
                  '### Maintenance Task Type',
                  'Other',
                  '### Specific Tasks',
                  '_Please specify the exact tasks to be completed._'
                ]);
            }
            
            // Update issue body and title
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: formattedBody,
              title: cleanedTitle
            });

      - name: Post Metadata Comment
        uses: actions/github-script@v7
        env:
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
          CONFIDENCE: ${{ env.CONFIDENCE }}
          GAPS: ${{ env.GAPS }}
          DETECTED_COMPONENT: ${{ env.DETECTED_COMPONENT }}
          DETECTED_STAKEHOLDER: ${{ env.DETECTED_STAKEHOLDER }}
        with:
          script: |
            const issue = context.payload.issue;
            const issueType = process.env.ISSUE_TYPE || 'task';
            const confidence = process.env.CONFIDENCE || '50';
            const detectedComponent = process.env.DETECTED_COMPONENT || 'Other';
            const detectedStakeholder = process.env.DETECTED_STAKEHOLDER || 'End User';
            
            // Parse gaps safely
            let gaps = [];
            try {
              gaps = JSON.parse(process.env.GAPS || '[]');
            } catch (e) {
              console.log('Failed to parse gaps, using empty array');
              gaps = [];
            }
            
            // Build metadata comment
            let gapsList = gaps.length > 0 
              ? gaps.map(g => `- ${g}`).join('\n')
              : '- None identified';
            
            const metadataComment = [
              '## ðŸ¤– Agent Processing Metadata',
              '',
              '| Metric | Value |',
              '|--------|-------|',
              '| **Classification** | ' + issueType.charAt(0).toUpperCase() + issueType.slice(1) + ' |',
              '| **Confidence** | ' + confidence + '% |',
              '| **Detected Component** | ' + detectedComponent + ' |',
              '| **Detected Stakeholder** | ' + detectedStakeholder + ' |',
              '| **Processing Time** | ' + new Date().toISOString() + ' |',
              '',
              '### Gap Analysis',
              '',
              'The following information was not found in the original submission:',
              '',
              gapsList,
              '',
              '---',
              '',
              '> **Note**: This issue was automatically formatted by the Issue Triage Agent.',
              '> The original content has been preserved in a separate comment above.',
              '> Component and stakeholder information have been applied as labels.',
              '> Please review and update any missing sections as needed.'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: metadataComment
            });

      - name: Update Labels
        uses: actions/github-script@v7
        env:
          ISSUE_TYPE: ${{ env.ISSUE_TYPE }}
          DETECTED_COMPONENT: ${{ env.DETECTED_COMPONENT }}
          DETECTED_STAKEHOLDER: ${{ env.DETECTED_STAKEHOLDER }}
        with:
          script: |
            const issue = context.payload.issue;
            const issueType = process.env.ISSUE_TYPE || 'task';
            const detectedComponent = process.env.DETECTED_COMPONENT || 'Other';
            const detectedStakeholder = process.env.DETECTED_STAKEHOLDER || 'End User';
            
            // Remove triage:agent-pending label
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: 'triage:agent-pending'
              });
            } catch (e) {
              const status = e?.status ?? e?.response?.status;
              if (status === 404) {
                console.log('Label triage:agent-pending not found or already removed');
              } else {
                throw e;
              }
            }
            
            // Add triage:agent-processed label
            const labelsToAdd = ['triage:agent-processed'];
            
            // Add type-specific labels based on classification
            switch (issueType) {
              case 'bug':
                labelsToAdd.push('bug');
                break;
              case 'feature':
                labelsToAdd.push('feature');
                break;
              case 'documentation':
                labelsToAdd.push('documentation');
                break;
              case 'performance':
                labelsToAdd.push('performance');
                break;
              default:
                labelsToAdd.push('chore');
            }
            
            // Add component label based on detected component
            const componentLabelMap = {
              'CLI': 'component:cli',
              'Scanner': 'component:scanner',
              'Trakt Integration': 'component:trakt',
              'Config': 'component:config',
              'Reporter': 'component:reporter',
              'Output': 'component:output',
              'Docker': 'component:docker',
              'CI/CD': 'component:cicd',
              'GitHub Actions': 'component:github-actions',
              'Tests': 'component:tests',
              'Documentation': 'component:docs',
              'Unknown': 'component:unknown',
              'Other': 'component:other'
            };
            
            const componentLabel = componentLabelMap[detectedComponent];
            if (componentLabel) {
              labelsToAdd.push(componentLabel);
            }
            
            // Add stakeholder label based on detected stakeholder
            const stakeholderLabelMap = {
              'Project Maintainer': 'stakeholder:maintainer',
              'Contributor': 'stakeholder:contributor',
              'End User': 'stakeholder:user'
            };
            
            const stakeholderLabel = stakeholderLabelMap[detectedStakeholder];
            if (stakeholderLabel) {
              labelsToAdd.push(stakeholderLabel);
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labelsToAdd
            });

      - name: Assign Issue to Copilot
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            
            // Assign the triaged issue to Copilot
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: ['Copilot']
            });
